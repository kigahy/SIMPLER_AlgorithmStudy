'''
NxN 배열에 숫자가 들어있다. 한 줄에서 하나씩 N개의 숫자를 골라 합이 최소가 되도록 하려고 한다.
단, 세로로 같은 줄에서 두 개 이상의 숫자를 고를 수 없다.

테스트케이스 분석([[2,1,2],[5,8,5],[7,2,2]]
1. (0,0)을 선택한 경우 한 줄에서 하나만 숫자를 고를 수 있기 때문에 0번째 행의 다른 숫자 전체와 (0,0)이 포함된 열의 모든 숫자는 선택할 수 없다.
2. 1번째 행에서 선택할 수 있는 숫자의 경우의 수는 (1,1)과 (1,2) 2가지 뿐이다.
3. (1,1)을 선택하는 경우 1과 동일한 논리로 (1,2)와 (2,1)이 선택할 수 없는 숫자가 된다.
4. 따라서 2번째 행에서는 선택할 수 있는 경우의 수가 1가지(2,2) 뿐이다.
5. 2에서 (1,2)를 선택한 경우 2와 3에서와 동일한 논리로 2번째 행에서 선택할 수 있는 숫자는 (2,1)밖에 없다.

문제접근
1. (0,0)을 고른 경우, (0,1)을 고른 경우, (0,2)를 고른 경우 ... (0,N-1)을 고른 경우로 케이스를 나눠서 생각한다.
2. (0,0)을 고른 경우 (0,0)을 dummy_list에 넣고 십자방향의 모든 행렬값을 0으로 재할당한다.
3. 1번째 행으로 내려가 0이 아닌 행렬값에 대해 2를 반복한다.
'''
import sys
sys.stdin = open("4881_input.txt", "r")

def find_min(N,arr):
    for i,lst in arr:
        for j,elem in lst:



T = int(input())
for test_case in range(1, T + 1):
    N = int(input())
    arr = [list(map(int,input().split())) for _ in range(N)]
    print(f'#{test_case} {find_min(N,arr)}')