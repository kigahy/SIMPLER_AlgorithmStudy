# 삽입 정렬 #

i번째 순서와 i-1번째 순서에 있는 값을 비교하여 더 작은 수를 왼쪽으로 정렬하는 알고리즘

### 1. 5에서 시작
`[6, 5, 8, 2]`

### 2. 5를 6과 비교 후 위치 교환
`[5, 6, 8, 2]`

### 3. 정렬되지 않은 8을 6과 비교
`[5, 6, 8, 2]`
- 8이 6보다 크므로 순서가 그대로임

### 4. 6보다 더 앞의 값인 5와 8을 비교하려 했으나, 왼쪽의 5, 6은 이미 정렬됨
`[5, 6, 8, 2]`

### 5. 정렬되지 않은 2를 8과 비교
`[5, 6, 2, 8]`
- 2가 8보다 작으므로 순서 변경

### 6. 6과 2 비교
`[5, 2, 6, 8]`
- 2가 6보다 작으므로 순서 변경

### 7. 5과 2 비교
`[2, 5, 6, 8]`
- 정렬 완료

## 코드로 알아보기
```
def insertion_sort(a_list):
    for i in range (1, len(a_list)):
        value = a_list[i]
        # for문으로 검사. 인덱스번호는 1로, 자신의 왼쪽 값과 비교하기 위함

        while i > 0 and a_list[i-1] > value :
        a_list[i] = a_list[i-1]
        # 현재 인덱스에 직전값을 삽입
        i = i - 1
        # 인덱스 번호가 1 이상이고 해당 인덱스번호값의 전 값[i-1]이 현재 인덱스번호값보다 더 크면 해당 인덱스 값에 전 값 저장
        그리고 인덱스 번호 값을 1씩 줄여가며 더 앞의 값과도 비교
        # i가 0이므로 while루프 종료

        a_list[i] = value
        # i-1로 줄어든 인덱스, 즉 그 전값에 현재 인덱스의 값을 삽입
        # 바꾸기 전 i인덱스의 값을 저장한 value를 직전 함수에 저장
```        

## 삽입 정렬의 사용
`[1, 2, 3, 4, 5, 7, 6]`
- O(n^2)의 시간 복잡도로 그다지 효율적이지 않음
- 정렬되지 않은 마지막 두 개 숫자만 비교하면 되므로 while문이 단 한번 실행되어 시간 복잡도가 선형일 때