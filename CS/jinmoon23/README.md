# Part1. 1~2장

## 시간복잡도

- 시간(공간)복잡도의 지표

    ``O(n**1) -> n**1은 방정식의 차수``
    
    `ex, f(n) = 1 + 2n -> O(n**1)`

    `ex, f(n) = 2 + n**2 -> O(n**2)` 

    f(n)은 연산의 횟수라고 러프하게 이해해도 문제가 없음
    ```py
    count = 0
    for i in range(n):
        print(count)
        count += 1
    ```
    이 코드는 f(n) = 1 + n + 1 + 1 로 시간복잡도를 표현 가능
- 알고리즘의 단계를 아는 것 보다 n의 변화에 따른 성능 변화를 아는 것이 더 중요하다.
- 2번 중첩된 for문은 n**2의 시간복잡도를 가진다. 알고리즘 최적화의 핵심은 이 중첩for문을 사용하지 않고 동일한 동작을 수행할 수 있는가를 찾는 것. 

## 재귀함수
팩토리얼의 연산 과정을 통해 재귀함수의 동작원리를 이해할 수 있다. 
```py
def factorial(n):
    if n == 0:
        return 1
    return n * factorial(n-1)
```
해당 코드를 설명하기 전에 Stack을 이해해야 한다. stack은 마지막에 넣은 값을 가장 먼저 뺀다는 매커니즘임.

이제 n에 3을 넣어보면서 스택을 이해해보자.
```py
# stack memory
3 * factorial(3-1) # 1번째 스택에 3 저장
2 * factorial(2-1) # 2번째 스택에 2 저장
1 * factorial(1-1) # 3번째 스택에 1 저장
1 # if문에서 탈출. 가장 마지막에 넣은 stack meory, 반드시 탈출코드에 의한 값이어야 함.

# stack 연산이 모두 종료되었기 때문에 factoral(0~2)의 값이 확정되어 연산을 시작할 수 있음

return 1 * 2 * 3 = 6  
```