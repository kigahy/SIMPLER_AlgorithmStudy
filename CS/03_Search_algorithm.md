# 7월 25일 CS스터디(나의 첫 알고리즘 + 자료구조 with 파이썬)
## Chapter03. 탐색 알고리즘
- 탐색 능력 : 사용자가 플랫폼에 더 오래 머물게 하기 위해 데이터 가공
- 파이썬에는 탐색 알고리즘이 내장되어 있다.
### 선형 탐색
- 선형 탐색 : 데이터 세트에 들어있는 모든 요소를 비교하면서 원하는 데이터를 찾는 탐색 방식(어느 한 요소를 검사하는 알고리즘이라서)
- 선형 탐색 알고리즘의 시간 복잡도는 0(n)이고, 선형 탐색 알고리즘은 평균적으로 n/2번의 단계를 거친다.
- python에서의 선형 탐색 예시
```python
def linear_search(a_list, n):
    for i in a_list:
        if i == n:
            return True
    return False

a_list = [1, 8, 32, 91, 5, 15, 9, 100, 3]
print(linear_search(a_list, 91))

# 실험 결과 : True
```
- 선형 탐색을 사용해야 할 때
    - 데이터가 정렬되어 있지 않을 때
    - 실제 프로그래밍 시 선형 탐색 알고리즘을 직접 작성하기 보다 파이썬에 내장된 in 키워드를 쓰는 것이 좋다.
    ```python
    unsorted_list = [1, 45, 4, 32, 3]
    print(45 in unsorted_list)
    # 실행 결과 : True
    # 숫자 뿐만 아니라 문자열도 가능
    ```

### 이진 탐색
- 이진 탐색 : 리스트에서 숫자를 더 빠르게 탐색할 수 있는 알고리즘
- 이진 탐색은 리스트를 1/2로 줄여 나가는 탐색 방식이다.(up, down)
- 이진 탐색의 시간 복잡도는 0(log n)
- 이진 탐색은 로그 함수의 도움을 받아 탐색의 단계를 정리할 수 있다.
    - 이진 탐색의 단계를 진행할수록 리스트에는 전 단계의 1/2개만큼 요소가 남는다.
    - 이를 반복하여 이진 탐색의 단계를 x번 반복했을 때 리스트가 n/(2**x)개로 줄어든다.
    - 만약 100개의 숫자가 들어있는 리스트에서 이진 탐색을 끝까지 진행했을 때 log2(100)번의 탐색을 한다.(2**7 = 128이므로)
- python에서의 이진 탐색 예시
```python
def binary_search(a_list, n):
    first = 0                       # 리스트의 첫 번째 인덱스
    last = len(a_list) - 1          # 리스트의 마지막 인덱스
    while last >= first:
        mid = (first + last) // 2   # 중앙값 인덱스
        if a_list[mid] == n:        # 찾는 값이 중앙값일 때
            return True
        else:
            if n < a_list[mid]:     # 찾는 값이 중앙값보다 작을 때
                last = mid - 1
            else:
                first = mid + 1     # 찾는 값이 중앙값보다 클 때
    return False
```
- 이진 탐색을 사용해야 할 때
    - 데이터가 정렬되어 있다면 보통 이진 탐색을 사용하는 것이 좋다.
    - 데이터가 정렬되어 있지 않아도 정렬에 시간이 많이 걸리지 않으면 정렬 후 이진 탐색을 사용하는 것이 좋을 수도 있다.
- python에 내장된 이진 탐색을 위한 모듈
```python
from bisect import bisect_left

sorted_fruits = ['apple', 'banana', 'orange', 'plum']
bisect_left(sorted_fruits, 'banana')    # 실행 결과 : 1
bisect_left(sorted_fruits, 'kiwi')      # 실행 결과 : 2(예상 값 반환)
```
### 문자 탐색
- 문자 탐색 방법을 이해하려면 컴퓨터가 문자를 어떻게 저장하는지부터 알아야 한다.
- 문자 세트 : 문자와 이진수의 연결을 의미
- 컴퓨터 과학자는 문자 인코딩(코드화 또는 부호화)을 사용해 여러 가지 문자 세트를 만든다.
    - ASCII에서는 2**7 = 128개의 문자 표현
    - 대부분의 컴퓨터는 ASCII를 8비트로 확장해 256개의 문자를 표현
    - 하지만 일본어나 중국어 같은 언어의 문자를 나타내기에는 부족하여 이를 해결하기 위해 유니코드 문자 세트를 만듦(ex. UTF-8 문자 인코딩 방법 중 하나, 32비트까지 가능하여 백만 개 이상의 문자 표현 가능)
    - UTF-8은 알파벳을 저장할 때 ASCII와 같은 숫자를 사용하기 때문에 ASCII와 호환이 된다.
- ord() 함수는 문자의 ASCII 코드를 직접 다룰 때 적합
- 이진 탐색 알고리즘으로 문자를 탐색하려면 각 문자의 ASCII 코드 값을 가져와 비교

- 하지만 가장 효율적인 탐색 방법은 해시 테이블이다.

## Chapter04. 정렬 알고리즘
- 데이터 정렬 : 데이터를 일정한 순서로 배치하는 것(다양한 방식의 정렬 존재)
### 버블 정렬
- 버블 정렬 : 숫자 리스트를 순회하면서 각 숫자를 다음 숫자와 비교하고, 순서가 올바르지 않으면 둘의 위치를 바꾸는 알고리즘(액체 속에서 공기방울이 올라가는 것처럼 보여서)
- python에서의 버블 정렬 예시 [32, 1, 9, 6]
```python
def bubble_sort(a_list):
    list_length = len(a_list) - 1
    for i in range(list_length):
        for j in range(list_length):
        # for j in range(list_length - i): ==> 마지막 숫자의 비교를 생략하는 이유는 리스트가 이미 그만큼 정렬됐기 때문이다.
            if a_list[j] > a_list[j+1]:
                a_list[j], a_list[j+1] = a_list[j+1], a_list[j]
    return a_list
```
- 버블 정렬을 사용해야 할 때
    - 버블 정렬을 포함한 모든 정렬 알고리즘은 문자열 정렬에도 사용 가능하다.
    - 버블 정렬의 장점은 알고리즘이 단순한 편이라 정렬 알고리즘을 배우는 출발점으로 적합
    - 버블 정렬은 두 번 중첩된 for 루프에 의존하므로 시간 복잡도는 0(n**2)이므로 데이터 세트가 작을 때 효율적이다.
    - 버블 정렬은 안정적이다.(안정적인 정렬 : 정렬 기준 이외의 요인 때문에 리스트의 순서가 바뀌지 않는다.)