'''
그는 무조건 예약제로만 손님을 받으며, 예약을 하려는 손님들은 진기의 까다로운 자격 검증에서 합격해야만 붕어빵을 맛 볼 자격을 얻는다.
그래서 오늘은 N명의 사람이 자격을 얻었다.
진기는 0초부터 붕어빵을 만들기 시작하며, M초의 시간을 들이면 K개의 붕어빵을 만들 수 있다.
붕어빵이 완성되면 어떤 시간 지연도 없이 다음 붕어빵 만들기를 시작할 수 있다.
0초 이후에 손님들이 언제 도착하는지 주어지면,
모든 손님들에게 기다리는 시간없이 붕어빵을 제공할 수 있는지 없는지 판별하는 프로그램을 작성하라.

N = 사람의 수
M 초의 시간을 들이면 K개의 붕어빵을 만들 수 있다.
M = 4 / K = 2 라면 4초의 시간을 들여 2개의 붕어빵 생산 -> 2초의 시간을 들여 1개의 붕어빵 생산 -> 1초의 시간에 1/2개의 붕어빵 생산
즉, 1초에 K/M 개의 붕어빵 생산이 가능
만약 M = 5 / K = 2 라면 1초에 2/5 = 2.5개의 붕어빵 생산이 가능. 하지만 0.5개의 붕어빵은 제대로된 생산으로 보면 안되므로 // 연산자를 사용해야한다.
즉, M = 5 / K = 2 라면 1초에 2//5 인 2개의 붕어빵 생산이 가능.
K//M 은 붕어빵 생산성을 나타내는 정수.

2번째 테스트 케이스(2 2 2 / 1 2)의 경우, 2초가 지날 때마다 붕어빵을 2개씩 만들 수 있다. 1초에 1개씩 만들 수 있지만 2초가 지나야만 제대로된 붕어빵이 생산됨.
하지만 손님 1명은 1초에 도착하므로 이 손님에게는 붕어빵을 바로 제공할 수 없다.

문제접근
1.입력이 2 2 1 /  3 5 로 들어온 경우
2. 손님도착리스트 = [0,0,1,0,1] / 붕어빵완성리스트 = [0,1,0,1,0] 를 생성
    2-1. 손님도착리스트의 2번째 인덱스 값 1은 (2+1)초에 손님이 1명 온다는 의미
    2-2. 붕어빵완성리스트의 1번째 인덱스 값은 (1+1)초에 1개의 붕어빵이 만들어진다는 의미
3. 손님도착리스트를 순회하다가 1을 발견하면(위와 같은 경우 인덱스 2)
4. 붕어빵완성리스트에서 인덱스 2 이하에서 1이상의 수가 있는지 확인하고
5. 없다면 바로 impossible을 리턴
6. 있다면 붕어빵완성리스트와 손님도착리스트 각각의 그 값을 1 감소시키고 계속 순회
7. 순회가 마무리되고 손님도착리스트의 모든 값이 0이 되면 possible 리턴
'''

import sys
sys.stdin = open("input.txt", "r")

def check_serving(N,M,K,f_list,c_list):
    for i in range(N):
        if c_list[i] != 0:
            for j in range(i+1):
                if f_list[j] > 0:
                    while c_list != 0:
                        c_list[i] -= 1
                        f_list[j] -= 1

T = int(input())
for test_case in range(1, T + 1):
    N, M, K = map(int,input().split())
    prod_num = 1
    if N > K:
        prod_num += N // K
    arrive_arr = list(map(int,input().split()))
    c_list = [0] * (max(arrive_arr)+1)
    for arrive in arrive_arr:
        if arrive != 0:
            c_list[arrive] +=1

    f_list = [0] * M * prod_num
    for i in range(prod_num):
        f_list[M - 1] = K
    print(f'#{test_case} {check_serving(N,M,K,f_list,c_list)}')