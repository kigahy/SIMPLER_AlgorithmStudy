'''
dfs 재귀호출과 백트래킹을 통한 가지치기가 필요한 문제

핵심개념
1. 함수가 정방향으로 진행되다가 재귀호출을 만나 더 깊은 함수실행이 발생한 때 j가 어떤 값인지 체크해 두는 것이 이해에 큰 도움이 됨.
2. 깊은 함수가 종료된 경우 다시 정방향으로 함수가 진행된다는 점이 중요

테스트케이스 분석 [[2,1,2],[5,8,5],[7,5,2]]

1번째 호출, dfs(0,0) / j == 0 / v == [0,0,0]
2번째 호출, dfs(1,2) / j == 1 / v == [1,0,0]
3번째 호출, dfs(2,10) / j == 2 / v == [1,1,0]
4번째 호출, dfs(3,12) / j == 2 / v == [1,1,1]
    ans = 12 재할당 / i == N -> 함수종료 -> 3번째 호출로 돌아가 함수 계속 진행
    v[j] = 0 -> v == [1,1,0] 재할당
    3번째 호출 시 j == 2 상태였으므로 재할당 직후 함수 종료 -> 2번째 호출로 돌아가 함수 계속 진행
    v[j] = 0 -> v == [1,0,0] 재할당
    2번째 호출 시  j == 1 상태였으므로 재할당 직후 for문 계속 진행 -> v = [1,0,1]

5번째 호출, dfs(1,2) / j == 2 / v = [1,0,1]
6번째 호출, dfs(2,7) / j == 1 / v = [1,1,1]
7번째 호출, dfs(3,9) / j == 1 / v = [1,1,1]
    ans <= sm 을 충족하지 않기 때문에 가지치기의 대상이 아님.
    i == N -> 함수종료 -> 6번째 호출로 돌아가 함수 계속 진행
    v[j] = 0 -> v == [1,0,1] 재할당
    6번째 호출 시 j == 1 상태였으므로 재할당 직후 for문 계속 진행(j==2), but v[j] != 0 이므로 함수 종료
    5번째 호출로 돌아가 함수 계속 진행 -> v[j] = 0 -> v == [1,0,0] but 재할당 직후 j == 2 이므로 함수 종료
    1번째 최초 호출로 돌아가 함수 계속 진행 -> v[j] = 0 -> [0,0,0]
    이후 i == 0, j == 1로 1번째 호출의 for문 계속 진행.
'''

import sys
sys.stdin = open("4881_input.txt", "r")

def dfs(i, sm):
    global ans
    if ans <= sm: # 백트래킹(가지치기), 만약 ans 보다 sm값이 큰 경우 추가적인 연산을 제한해 시간복잡도를 개선하는 역할.
        return

    if i == N: # i == N 이 True가 되면 모든 행에 대한 탐색이 끝났다는 의미
        ans = min(ans, sm)
        return

    for j in range(N):
        if v[j] == 0:
            v[j] = 1
            dfs(i + 1, sm + arr[i][j])
            v[j] = 0

T = int(input())
for test_case in range(1, T + 1):
    N = int(input())
    arr = [list(map(int,input().split())) for _ in range(N)]

    ans = 10 * N # 최소값 판단을 위해 가능한 합 중 가장 큰 값을 설정
    v = [0] * N # 방문기록을 남기기 위한 visited 배열
    dfs(0, 0) # 행에 접근하기 위한 i값과 sum을 의미하는 sm값을 인자로 넘겨 dfs함수 재귀호출 시작

    print(f'#{test_case} {ans}')